## 포인터와 동적 객체 생성



--------



#### < ex01_pointer.cpp >



**`#include <iostream>`**

**`using namespace std;`**



**`int main(int argc, char const *argv[]) {`**

  **`int number = 0;`**

**`double d = 20.2;`**



  **`int *p = &number;`**

`// 가리키고 있는 곳이 int여야 한다, 다른 변수형(ex)double)이면 안 된다`

`// int에 대한 포인터`

`// p = &d; -> 에러`

**`double *pd = &d;`**



  **`cout << p << endl; // 주소 출력`**

  **`cout << *p << endl; // 주소가 가지고 있는 값을 출력`**



  **`return 0;`**

**`}`**



출력

`0x61fe14`
`0`



- **포인터(pointer)**
  - <u>메모리의 주소값을 저장하는 변수</u>
  - <u>c++에서 주소는 4byte로 관리한다</u>
  - <u>변수 선언시 타입 뒤에 *를 지정</u>
  - <u>int *p; // 정수를 가리키는 포인터 선언</u>
- **주소 연산자 &**
  - <u>기존 변수의 주소값을 획득하여 포인터 변수에 저장할 때 사용</u>
  - <u>대입문 왼쪽 & ex) int &total = sum;-> 참조</u>
  - <u>대입문 오른쪽 & ex) p = &number;-> 주소 연산자, 이 변수의 주소를 대입하겠다</u> 
  - <u>int num = 10;</u>
  - <u>int *p; // 정수를 가리키는 포인터 선언 *</u>
  - <u>p = &number; // 주소값을 획득할 때는 &</u>

- **간접 참조 연산자 ***

  - <u>나는 주소보다 주소에 있는 값을 알고 싶다</u>

  - <u>포인터 변수에는 주소가 저장되어 있음</u>

  - <u>그 주소에 있는 데이터를 얻을 때 사용</u>

  - <u>cout << p; -> 주소값 출력</u>

  - <u>cout << *p; -> p가 가지고 있는 주소에 있는 값을 출력</u>

    

- <u>선언문의 * -> 포인터 변수를 선언</u>
- <u>실행문의 * -> 포인터 변수가 가리키는 값을 읽겠다</u>

- <u>파이썬에서는 주소값을 직접 배정할 수도 주소값을 알 수도 없지만 c++은 모두 가능하다</u>
- <u>파이썬의 참조는 항상 heap에 대한 참조이다</u>
- <u>c++은 스택의 다른 곳 접근 가능, 데이터 타입만 맞으면 스택에 있든 힙에 있든 상관없이 가능</u>



`int main(...){`

`int number = 100;`

`int *pNumber;`

`cout << *pNumber;`

`}`



#### < ex02_null.cpp >



**`#include <iostream>`**

**`using namespace std;`**



**`void f(int i){`**

  **`cout << "f(int)" << endl;`**

**`}`**



**`void f(char *p){`**

  **`cout << "f(char *)" << endl;`**

**`}`**



**`int main(int argc, char const *argv[]) {`**

  **`//f(NULL); -> int, char * 둘 다 가능하므로 에러`**

  **`// f(nullptr); // nullptr: 포인터 NULL을 의미하는 키워드`** 



  **`int *pNumber = NULL; // 권장`**!

  **`int *pNumber2; // 권장하지 않음`**

  **`// 무슨 값이 들어있는지 모른다! 임의의 초기값을 가짐`**



  **`if(pNumber != NULL){`**

​    **`cout << *pNumber << endl;`**

  **`}`**  



  **`if(pNumber2 != NULL){`**

​    **`cout << *pNumber2 << endl;`**

  **`}`**

  **`f(nullptr);`**

  **`f(0);`**

  **`return 0;`**

**`}`**



-------



- **프로그램에서 메모리**

  - **스택(stack)**
    - 지역 변수 할당 (정적 할당)
    - 시스템에 의해서 관리 (함수호출시 생기고, 함수 끝나면 사라짐)

  - **힙(heap)**
    - 동적 메모리 할당 (할당 시점과 삭제 시점이 규칙으로 정해져 있지 않다)
    - 개발자에 의해 관리
      - 생성 - new
      - 삭제 - delete

- **new, delete**

  - **new**
    - 동적으로 <u>힙</u>에 메모리를 할당
    - new의 리턴값은 주소
    - new는 포인터 변수가 받을 수 있다
  - **delete** (cleanup 작업을 할 때 사용하는 명령어)
    - 동적으로 힙에 할당된 메모리를 회수
    - 파괴자가 호출됨
    - 동적 메모리를 회수하지 않으면 가비지 증가
    - delete 뒤엔 포인터 변수만 올 수 있다
  - class T{};
  - T *p = new T;

  - T *p = new T[N];
  - T *p = new T[N] {초기화....};

- 스택에 접근하는 방법은 주소를 통해서만 가능하다



`int main(..){`

`int *pNumber; // 초기화 안 했으니 임의의 값`



`deleter pNumber; // 안전하게 운영하려면 초기화를 NULL로 하고 if문으로 pNumber != NULL로 검사하고 delete하는 것이 안전하다!`

`// <u>new하지 않고, 배정하지도 않고 delete를 하게 된다면? 대부분 어플리케이션이 죽는</u>다`

`// 스택을 가리키고 있다면.. 못 지운다 죽는다`

`// 우연치 않게 힙을 가리키고 있다면? 올바른 행위 아니므로 죽는다`

`}`





`int *pA = new int(10);`

`int *pB = pA; //pA자체가 주소(& 쓸 필요 없다)`



`delete pA;`

`delete pB; // 이미 지운 것을 또 지우겠다고 할 경우도 에러`